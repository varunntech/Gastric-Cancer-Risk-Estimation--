# app.py

import joblib
import pandas as pd
import sqlite3
import jwt
import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from flask import Flask, request, jsonify, render_template, make_response
from flask_cors import CORS
from fpdf import FPDF
from io import BytesIO 

SECRET_KEY = "supersecretkey"  # Change this in production! 

# --- Configuration ---
try:
    # Load the trained detection model and features
    model = joblib.load("gastric_detection_model.joblib")
    with open("gastric_detection_features.txt", "r") as f:
        MODEL_FEATURES = [line.strip() for line in f]
except FileNotFoundError:
    print("FATAL ERROR: Detection model or feature file not found. Run 'train_and_save.py' first.")
    # exit() # Allow running even if model is missing for dev purposes

def init_db():
    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users 
                 (id INTEGER PRIMARY KEY AUTOINCREMENT, 
                  name TEXT, 
                  email TEXT UNIQUE, 
                  password TEXT)''')
    conn.commit()
    conn.close()

init_db()

app = Flask(__name__, template_folder="templates")
CORS(app)

# Columns treated as categorical during training (must match train_and_save.py)
CATEGORICAL_COLS = [
    "gender",
    "ethnicity",
    "geographical_location",
    "dietary_habits",
    "existing_conditions",
]

NUMERIC_COLS = [
    "age",
    "family_history",
    "smoking_habits",
    "alcohol_consumption",
    "helicobacter_pylori_infection",
]


# --- Routes ---

# DB Migration for Surname
def migrate_db():
    try:
        conn = sqlite3.connect("users.db")
        c = conn.cursor()
        # Check if column exists
        c.execute("PRAGMA table_info(users)")
        columns = [info[1] for info in c.fetchall()]
        if 'surname' not in columns:
            print("Migrating DB: Adding surname column...")
            c.execute("ALTER TABLE users ADD COLUMN surname TEXT")
            conn.commit()
        conn.close()
    except Exception as e:
        print(f"Migration Error: {e}")

migrate_db()

@app.route('/api/auth/signup', methods=['POST'])
def signup_api():
    data = request.json
    name = data.get('name')
    surname = data.get('surname', '')
    email = data.get('email')
    password = data.get('password')

    if not all([name, email, password]):
        return jsonify({'message': 'Missing data'}), 400

    hashed_password = generate_password_hash(password)

    try:
        conn = sqlite3.connect("users.db")
        c = conn.cursor()
        c.execute("INSERT INTO users (name, surname, email, password) VALUES (?, ?, ?, ?)", (name, surname, email, hashed_password))
        conn.commit()
        conn.close()
        
        token = jwt.encode({
            'user': email,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }, SECRET_KEY, algorithm="HS256")

        return jsonify({'token': token, 'user': {'name': f"{name} {surname}".strip(), 'email': email}})

    except sqlite3.IntegrityError:
        return jsonify({'message': 'User already exists'}), 409
    except Exception as e:
        return jsonify({'message': str(e)}), 500

@app.route('/api/auth/login', methods=['POST'])
def login_api():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE email=?", (email,))
    user = c.fetchone()
    conn.close()

    if user and check_password_hash(user[3], password):
        token = jwt.encode({
            'user': email,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }, SECRET_KEY, algorithm="HS256")
        
        # user[1] is name, user[4] is surname if it exists (schema dependent)
        # Safely get surname if available
        surname = ""
        try:
            # Re-fetch with row factory or specific columns to be safe,
            # or assume it's the last column if we just added it.
            # user tuple: (id, name, email, password, surname)
            if len(user) > 4:
                surname = user[4] or ""
        except:
            pass
            
        full_name = f"{user[1]} {surname}".strip()
        
        return jsonify({'token': token, 'user': {'name': full_name, 'email': email}})
    
    return jsonify({'message': 'Invalid credentials'}), 401

@app.route('/')
def root():
    """Redirect root to home page."""
    name = request.args.get('name')
    resp = make_response(render_template('home.html', name=name))
    if name:
        resp.set_cookie('username', name)
    return resp

@app.route('/home')
def home():
    """Landing/home page."""
    name = request.args.get('name') or request.cookies.get('username')
    return render_template('home.html', name=name)

@app.route('/about')
def about():
    """About Us page."""
    return render_template('about.html')

@app.route('/risk')
def risk():
    """Risk assessment page."""
    name = request.cookies.get('username')
    return render_template('index.html', name=name)

@app.route('/login')
def login():
    """Login page - redirects to React app."""
    return render_template('login.html')

@app.route('/signup')
def signup():
    """Signup page - redirects to React app."""
    return render_template('signup.html')

@app.route('/api/download_report', methods=['POST'])
def download_report():
    data = request.json
    if not data:
        return jsonify({'message': 'No data provided'}), 400

    # Extract data
    risk_level = data.get('risk_level', 'Unknown').upper()
    probability = data.get('probability_of_cancer', 0)
    drivers = data.get('risk_drivers', [])
    recommendations = data.get('recommendations', [])
    date_str = data.get('date', datetime.datetime.now().strftime("%Y-%m-%d"))
    prob_percent = f"{float(probability) * 100:.2f}%"
    patient_name = data.get('patient_name', 'Guest').encode('latin-1', 'replace').decode('latin-1')

    # Create PDF
    pdf = FPDF()
    pdf.add_page()
    
    # Title
    pdf.set_font("Arial", 'B', 24)
    pdf.cell(0, 15, "Clinical Assessment Report", ln=True, align='C')
    pdf.set_font("Arial", '', 12)
    pdf.cell(0, 8, "Gastric Cancer Risk Estimation System", ln=True, align='C')
    pdf.cell(0, 8, f"Date: {date_str}", ln=True, align='C')
    pdf.cell(0, 8, f"Patient Name: {patient_name}", ln=True, align='C')
    pdf.ln(10)

    # Risk Profile
    pdf.set_fill_color(245, 245, 245)
    pdf.rect(10, pdf.get_y(), 190, 40, 'F')
    pdf.set_font("Arial", 'B', 16)
    pdf.cell(0, 10, "Risk Profile", ln=True)
    pdf.ln(5)

    pdf.set_font("Arial", '', 12)
    current_y = pdf.get_y()
    
    # Analysis Result
    pdf.set_xy(30, current_y)
    pdf.cell(60, 6, "Analysis Result", ln=True, align='C')
    pdf.set_font("Arial", 'B', 20)
    
    # Color logic isn't supported directly in cell text easily without multi-cell, 
    # but we can set text color.
    if risk_level == 'HIGH':
        pdf.set_text_color(211, 47, 47) # Red
    elif risk_level == 'MODERATE':
        pdf.set_text_color(239, 108, 0) # Orange
    else:
        pdf.set_text_color(46, 125, 50) # Green
        
    pdf.set_xy(30, current_y + 8)
    pdf.cell(60, 10, f"{risk_level} RISK", ln=True, align='C')
    pdf.set_text_color(0, 0, 0) # Reset

    # Probability
    pdf.set_xy(120, current_y)
    pdf.set_font("Arial", '', 12)
    pdf.cell(60, 6, "Estimated Probability", ln=True, align='C')
    pdf.set_font("Arial", 'B', 20)
    pdf.set_xy(120, current_y + 8)
    pdf.cell(60, 10, prob_percent, ln=True, align='C')
    
    pdf.ln(20)

    # Top Risk Drivers
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "Top Risk Drivers", ln=True)
    pdf.line(10, pdf.get_y(), 200, pdf.get_y())
    pdf.ln(5)

    pdf.set_font("Arial", '', 12)
    if drivers:
        for driver in drivers:
            name = driver.get('name', '').encode('latin-1', 'replace').decode('latin-1')
            impact = driver.get('impact', '').encode('latin-1', 'replace').decode('latin-1')
            pdf.set_font("Arial", 'B', 12)
            pdf.write(5, f"- {name}")
            pdf.set_font("Arial", '', 11)
            pdf.write(5, f" ({impact} Impact)")
            pdf.ln(8)
    else:
        pdf.cell(0, 10, "No specific major risk drivers identified.", ln=True)
    
    pdf.ln(10)

    # Recommendations
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "Recommended Next Steps", ln=True)
    pdf.line(10, pdf.get_y(), 200, pdf.get_y())
    pdf.ln(5)

    pdf.set_font("Arial", '', 12)
    if recommendations:
        for step in recommendations:
            step_clean = step.encode('latin-1', 'replace').decode('latin-1')
            pdf.write(5, f"- {step_clean}")
            pdf.ln(8)
    else:
        pdf.cell(0, 10, "Consult a healthcare provider.", ln=True)

    # Disclaimer
    pdf.ln(20)
    pdf.set_font("Arial", 'I', 10)
    pdf.set_text_color(100, 100, 100)
    pdf.multi_cell(0, 5, "DISCLAIMER: This report is generated by an AI Support Tool. It is NOT a definitive medical diagnosis. Please consult a qualified doctor for interpretation and clinical decisions.", align='C')

    # Output - FPDF classic way
    # dest='S' returns the document as a string.
    # We strip spaces as a safety precaution though strictly not needed for S.
    response_string = pdf.output(dest='S')
    
    # Encode to bytes for Flask response
    response_bytes = response_string.encode('latin-1')

    return make_response(response_bytes, 200, {
        'Content-Type': 'application/pdf',
        'Content-Disposition': f'attachment; filename=Gastric_Risk_Report_{date_str}.pdf'
    })

# --- Chatbot Logic ---
from pypdf import PdfReader
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import re

PDF_CONTENT = []
VECTORIZER = None
TFIDF_MATRIX = None

def load_pdf_content():
    global PDF_CONTENT, VECTORIZER, TFIDF_MATRIX
    try:
        reader = PdfReader("complete_gastric_cancer_handbook.pdf")
        text = ""
        for page in reader.pages:
            text += page.extract_text() + "\n"
        
        # Split into chunks (sentences or small paragraphs)
        # Simple splitting by period or newline for better granularity
        raw_chunks = re.split(r'(?<=[.!?])\s+', text)
        PDF_CONTENT = [chunk.strip() for chunk in raw_chunks if len(chunk.strip()) > 20]
        
        if PDF_CONTENT:
            VECTORIZER = TfidfVectorizer(stop_words='english')
            TFIDF_MATRIX = VECTORIZER.fit_transform(PDF_CONTENT)
            print(f"Chatbot: Loaded {len(PDF_CONTENT)} text chunks from PDF.")
        else:
            print("Chatbot: PDF content is empty.")
            
    except Exception as e:
        print(f"Chatbot Error: Failed to load PDF - {e}")

# Load on startup
load_pdf_content()

@app.route('/api/chat', methods=['POST'])
def chat_api():
    data = request.json
    user_query = data.get('message', '')
    
    if not user_query or not VECTORIZER or TFIDF_MATRIX is None:
        return jsonify({'response': "I'm sorry, I cannot answer that right now. The knowledge base might be unavailable."})

    try:
        # Transform query and find best match
        query_vec = VECTORIZER.transform([user_query])
        similarities = cosine_similarity(query_vec, TFIDF_MATRIX).flatten()
        best_idx = similarities.argmax()
        best_score = similarities[best_idx]
        
        if best_score > 0.1: # Threshold for relevance
            response = PDF_CONTENT[best_idx]
            return jsonify({'response': response})
        else:
            return jsonify({'response': "I couldn't find specific information about that in the guide. Please consult a doctor."})
            
    except Exception as e:
        print(f"Chatbot Query Error: {e}")
        return jsonify({'response': "Sorry, I ran into an error processing your question."})

@app.route('/predict', methods=['POST'])
def predict():
    """Handles the prediction request."""
    try:
        data = request.get_json(force=True) or {}

        # 1. Build a single-row DataFrame with expected columns
        all_cols = NUMERIC_COLS + CATEGORICAL_COLS
        row = {}
        for col in all_cols:
            value = data.get(col, None)
            row[col] = value

        input_df = pd.DataFrame([row])

        # 2. Simple imputation to avoid failures on missing values
        for col in NUMERIC_COLS:
            if col in input_df.columns:
                input_df[col] = pd.to_numeric(input_df[col], errors="coerce")
                median_val = input_df[col].median() if not pd.isna(input_df[col].median()) else 0
                input_df[col] = input_df[col].fillna(median_val)

        for col in CATEGORICAL_COLS:
            if col in input_df.columns:
                input_df[col] = input_df[col].fillna("Unknown")

        # 3. One-Hot Encode categorical variables (same as training)
        input_encoded = pd.get_dummies(input_df, columns=CATEGORICAL_COLS, drop_first=True)

        # 4. Align features with the training data
        final_input = input_encoded.reindex(columns=MODEL_FEATURES, fill_value=0)

        # 5. Make prediction – probability of gastric cancer (label = 1)
        prob_cancer = float(model.predict_proba(final_input)[:, 1][0])

        # 5a. Extract individual risk factors for balanced assessment
        row_clean = final_input.copy()
        # Work from original (pre-encoded) input_df for interpretability
        fh = int(round(float(input_df.get("family_history", 0).iloc[0] or 0)))
        hp = int(round(float(input_df.get("helicobacter_pylori_infection", 0).iloc[0] or 0)))
        smoke = int(round(float(input_df.get("smoking_habits", 0).iloc[0] or 0)))
        diet = str(input_df.get("dietary_habits", pd.Series(["Low_Salt"])).iloc[0] or "Low_Salt")
        cond = str(input_df.get("existing_conditions", pd.Series(["None"])).iloc[0] or "None")

        # Individual risk factor flags
        has_family_history = fh == 1
        has_h_pylori = hp == 1
        has_smoking = smoke == 1
        has_high_salt = diet == "High_Salt"
        has_chronic_gastritis = cond == "Chronic Gastritis"
        
        major_flags = [
            has_family_history,
            has_h_pylori,
            has_high_salt,
            has_chronic_gastritis,
            has_smoking,
        ]
        n_major = sum(major_flags)

        # 6. Convert probability into risk tier (initial assessment)
        if prob_cancer < 0.3:
            risk_level = "low"
            risk_text = "Low estimated chance of gastric cancer based on your answers."
        elif prob_cancer < 0.6:
            risk_level = "moderate"
            risk_text = "Moderate (borderline) risk – you should consider consulting a doctor for proper evaluation."
        else:
            risk_level = "high"
            risk_text = "High estimated chance – you should consult a doctor or gastroenterologist as soon as possible."

        # 6a. Rule: If there are NO major risk factors (only age/gender), cap risk at low
        if n_major == 0 and risk_level in ["moderate", "high"]:
            risk_level = "low"
            if prob_cancer >= 0.3:
                prob_cancer = 0.25  # Set to low risk range
            risk_text = (
                "Low estimated chance of gastric cancer based on your answers. "
                "You have no major risk factors present. However, regular health checkups are always recommended."
            )

        # 6b. Rule: If ONLY family history is present (no other risk factors), cap at low
        # Family history alone is not strong enough to warrant moderate risk
        if n_major == 1 and has_family_history and not (has_h_pylori or has_smoking or has_high_salt or has_chronic_gastritis):
            if risk_level in ["moderate", "high"]:
                risk_level = "low"
                if prob_cancer >= 0.3:
                    prob_cancer = 0.28  # Set to low risk range
                risk_text = (
                    "Low estimated chance of gastric cancer based on your answers. "
                    "While you have a family history, you have no other major risk factors present. "
                    "Regular health checkups and monitoring are recommended."
                )

        # 6c. Rule: Positive helicobacter pylori infection should result in at least moderate risk
        # H. pylori is a strong independent risk factor
        if has_h_pylori and risk_level == "low":
            risk_level = "moderate"
            if prob_cancer < 0.3:
                prob_cancer = 0.35  # Set to moderate range
            risk_text = (
                "Moderate risk – Helicobacter pylori infection is a significant risk factor for gastric cancer. "
                "You should consider consulting a doctor for proper evaluation and potential treatment."
            )

        # 6d. Rule: Chronic gastritis alone should result in at least moderate risk
        # Chronic gastritis is a medical condition that requires attention
        if n_major == 1 and has_chronic_gastritis and not (has_family_history or has_h_pylori or has_smoking or has_high_salt):
            if risk_level == "low":
                risk_level = "moderate"
                if prob_cancer < 0.3:
                    prob_cancer = 0.35
                risk_text = (
                    "Moderate risk – Chronic gastritis is a condition that requires medical attention. "
                    "You should consult a doctor for proper evaluation and management."
                )

        # 6e. Rule: If only one weak risk factor (smoking or high salt diet alone), cap at low
        # These factors alone are not strong enough for moderate risk
        if n_major == 1 and (has_smoking or has_high_salt) and not (has_family_history or has_h_pylori or has_chronic_gastritis):
            if risk_level in ["moderate", "high"]:
                risk_level = "low"
                if prob_cancer >= 0.3:
                    prob_cancer = 0.28
                risk_text = (
                    "Low estimated chance of gastric cancer based on your answers. "
                    "While you have one risk factor present, it alone is not sufficient for elevated risk. "
                    "However, reducing this risk factor and regular health checkups are recommended."
                )

        # 6f. Safety rule: if there is only 1 major risk factor (and it's not H. pylori or chronic gastritis),
        # do NOT allow the final tier to be "high". At most moderate.
        if n_major == 1 and risk_level == "high" and not (has_h_pylori or has_chronic_gastritis):
            risk_level = "moderate"
            if prob_cancer > 0.59:
                prob_cancer = 0.59
            risk_text = (
                "Moderate (borderline) risk – only one major risk factor was present. "
                "You may still wish to discuss this with a doctor, especially if symptoms persist."
            )

        # 6g. Final safety: If 2+ risk factors, allow model prediction to stand
        # But cap at moderate if only 2 factors and model says high (unless H. pylori + chronic gastritis)
        if n_major == 2 and risk_level == "high" and not (has_h_pylori and has_chronic_gastritis):
            risk_level = "moderate"
            if prob_cancer > 0.65:
                prob_cancer = 0.65
            risk_text = (
                "Moderate to high risk – you have multiple risk factors present. "
                "You should consult a doctor or gastroenterologist for proper evaluation."
            )

        # 7. Identify Risk Drivers for Clinical Report
        all_drivers = []
        if has_h_pylori:
            all_drivers.append({"name": "H. Pylori Infection", "impact": "High"})
        if has_family_history:
            all_drivers.append({"name": "Family History", "impact": "High"})
        if has_chronic_gastritis:
            all_drivers.append({"name": "Chronic Gastritis", "impact": "High"})
        if has_smoking:
            all_drivers.append({"name": "Smoking", "impact": "Medium"})
        if has_high_salt:
            all_drivers.append({"name": "High Salt Diet", "impact": "Medium"})
        if int(input_df.get("alcohol_consumption", 0).iloc[0] or 0) == 1:
            all_drivers.append({"name": "Alcohol Consumption", "impact": "Medium"})
        if int(input_df.get("age", 0).iloc[0] or 0) > 60:
            all_drivers.append({"name": "Age > 60", "impact": "Medium"})

        # Select Top 3
        top_drivers = all_drivers[:3]
        if not top_drivers:
            top_drivers = [{"name": "General Health Factors", "impact": "Low"}]

        # 8. Generate Recommended Next Steps
        recommendations = []
        if risk_level == "high":
            recommendations.append("Immediate consultation with a gastroenterologist.")
            recommendations.append("Schedule an Endoscopy (EGD) for detailed visualization.")
        elif risk_level == "moderate":
            recommendations.append("Consult a doctor for a physical examination.")
            recommendations.append("Consider non-invasive screening tests.")
        else: # Low
            recommendations.append("Continue regular health checkups.")
            recommendations.append("Maintain a healthy lifestyle.")

        # Specific recommendations based on drivers
        if has_h_pylori:
            recommendations.append("Discuss H. Pylori eradication therapy with your doctor.")
        if has_high_salt:
            recommendations.append("Reduce salt intake and avoid processed foods.")
        if has_smoking:
            recommendations.append("Join a smoking cessation program.")
        if has_chronic_gastritis:
            recommendations.append("Monitor for symptoms of dyspepsia or pain.")
        
        # Limit recommendations to top 4 to avoid clutter
        recommendations = recommendations[:4]

        result = {
            "probability_of_cancer": prob_cancer,
            "risk_level": risk_level,
            "message": risk_text,
            "risk_drivers": top_drivers,
            "recommendations": recommendations,
            "date": datetime.datetime.now().strftime("%Y-%m-%d")
        }

        return jsonify(result)

    except Exception as e:
        # Generic error handling
        return jsonify({'error': str(e), 'message': 'Prediction failed.'}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)